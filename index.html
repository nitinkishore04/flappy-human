<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Sad Flappy Bird</title>
    <style>
        body {
            margin: 0;
            background: #70c5ce;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            margin: auto;
            background: linear-gradient(#70c5ce, #ffffff);
        }

        #msg {
            position: absolute;
            width: 100%;
            text-align: center;
            top: 20px;
            color: #fff;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
    </style>
</head>

<body>
    <div id="msg">Click / Space = Flap</div> <canvas id="game" width="400" height="600"></canvas>
    <script>
        // ========= CANVAS & CONTEXT =========
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        // ========= ASSETS =========
        const birdImg = new Image();
        birdImg.src = "./img.png";

        // ========= GAME STATE =========
        const gameState = {
            bird: {
                x: 80,
                y: 200,
                w: 60,
                h: 60,
                gravity: 0.32,
                lift: -7,
                velocity: 0,
            },
            pipes: [],
            frame: 0,
            score: 0,
            gameOver: false,
        };

        const PIPE_CONFIG = {
            gap: 150,
            minTop: 50,
            maxTop: 300,
            width: 70,
            speed: 1.6,
            spawnInterval: 90,
        };

        // ========= EVENT LISTENERS =========
        document.addEventListener("keydown", (e) => {
            if (e.code === "Space") flap();
        });
        document.addEventListener("click", flap);

        // ========= CONTROLS =========
        function flap() {
            if (gameState.gameOver) {
                resetGame();
                return;
            }
            gameState.bird.velocity = gameState.bird.lift;
        }

        // ========= PIPE MANAGEMENT =========
        function spawnPipe() {
            const { gap, minTop, maxTop, width } = PIPE_CONFIG;
            const top = Math.random() * maxTop + minTop;
            gameState.pipes.push({
                x: canvas.width,
                top,
                bottom: canvas.height - top - gap,
                w: width,
                passed: false,
            });
        }

        function updatePipes() {
            gameState.pipes.forEach((pipe) => {
                pipe.x -= PIPE_CONFIG.speed;

                checkPipeCollision(pipe);
                checkPipeScore(pipe);
            });

            gameState.pipes = gameState.pipes.filter((p) => p.x + p.w > 0);
        }

        function checkPipeCollision(pipe) {
            const { bird } = gameState;
            if (
                bird.x < pipe.x + pipe.w &&
                bird.x + bird.w > pipe.x &&
                (bird.y < pipe.top || bird.y + bird.h > canvas.height - pipe.bottom)
            ) {
                gameState.gameOver = true;
            }
        }

        function checkPipeScore(pipe) {
            const { bird } = gameState;
            if (!pipe.passed && bird.x > pipe.x + pipe.w) {
                gameState.score++;
                pipe.passed = true;
            }
        }

        // ========= GAME LOGIC =========
        function update() {
            if (gameState.gameOver) return;

            gameState.frame++;

            if (gameState.frame % PIPE_CONFIG.spawnInterval === 0) {
                spawnPipe();
            }

            const { bird } = gameState;
            bird.velocity += bird.gravity;
            bird.y += bird.velocity;

            if (bird.y + bird.h > canvas.height || bird.y < 0) {
                gameState.gameOver = true;
            }

            updatePipes();
        }

        // ========= RENDERING =========
        function draw() {
            clearCanvas();
            drawBird();
            drawPipes();
            drawScore();

            if (gameState.gameOver) {
                drawGameOver();
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function drawBird() {
            const { bird } = gameState;
            const centerX = bird.x + bird.w / 2;
            const centerY = bird.y + bird.h / 2;
            const radius = bird.w / 2;

            ctx.save();
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();

            if (birdImg.complete && birdImg.naturalWidth > 0) {
                ctx.drawImage(birdImg, bird.x, bird.y, bird.w, bird.h);
            } else {
                ctx.fillStyle = "#ffcc00";
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawPipes() {
            ctx.fillStyle = "#2ecc71";
            gameState.pipes.forEach((pipe) => {
                ctx.fillRect(pipe.x, 0, pipe.w, pipe.top);
                ctx.fillRect(pipe.x, canvas.height - pipe.bottom, pipe.w, pipe.bottom);
            });
        }

        function drawScore() {
            ctx.fillStyle = "#fff";
            ctx.font = "30px Arial";
            ctx.fillText(gameState.score, 20, 50);
        }

        function drawGameOver() {
            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#fff";
            ctx.font = "40px Arial";
            ctx.fillText("Game Over", 100, 280);

            ctx.font = "20px Arial";
            ctx.fillText("Click to Restart", 120, 320);
        }

        // ========= GAME STATE RESET =========
        function resetGame() {
            gameState.bird.y = 200;
            gameState.bird.velocity = 0;
            gameState.pipes = [];
            gameState.score = 0;
            gameState.frame = 0;
            gameState.gameOver = false;
        }

        // ========= MAIN LOOP =========
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        loop();
    </script>
</body>

</html>
